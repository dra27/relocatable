#!/usr/bin/env bash

state_file="$(realpath $(dirname "$0"))/.stack-state"
dir="$(dirname $0)/ocaml"

if [[ ! -d $dir ]]; then
  echo "Expect OCaml clone in $dir" >&2
  exit 1
fi

cd "$dir"

if ! git rev-parse --verify upstream/trunk &> /dev/null; then
  echo 'Could not find upstream/trunk' >&2
  exit 1
fi

BRANCHES=()
TARGETS=()
COMMANDS=()

# Existing patches in maintenance branches and in opam-repository
# - Compatibility with -fno-common default in GCC 10 (#9180; 4.09.1)
#   opam-repository carries a different patch; passing -fcommon to configure
BRANCHES+=(fcommon@4.08)
# - SIGSTKSZ change in glibc 2.34 (#10266 and #10726; 4.13.0, 4.14.0)
#   opam-repository carries this patch already
BRANCHES+=(sigaltstack)
# - Correct configure script for 4.09.1
#   configure wasn't regenerated; opam-repository carries this patch already
BRANCHES+=(fix-4.09.1-configure@4.09)

# Existing patch in maintenance branch and proposed for opam-repository
# - Fix installing tools links when bytecode programs disabled (#8858; 4.09.1, 4.10.0)
#   Permits the disabling of bytecode tool installation on 4.08+
BRANCHES+=(install-bytecode@4.08)

# Existing patches in maintenance branches and proposed for opam-repository
# - Allow the reconfigure target on Windows (#8996; 4.09.1, 4.10.0)
#   **Critical**: graphics.4.08.0 and graphics.4.08.1 require it
BRANCHES+=(win-reconfigure@4.08)
# - Compatibility mingw-w64's ANSI stdio.h changes (#9939; 4.10.2, 4.11.2, 4.12.0)
#   **Critical**: OCaml doesn't build with mingw-w64 headers 8.0.0+ otherwise
BRANCHES+=(mingw-headers@4.09)

# Proposed back-ports to opam-repository only
# - SUBST_STRING macro in utils/Makefile (from #8650; 4.10.0)
#   Dependency of #9285
# - Link all DLLs with -static-libgcc on mingw32 (#9285 and #10046; 4.12.0)
#   **Critical**: i686 mingw-w64 OCaml requires a runtime DLL not available by
#                 default
BRANCHES+=(makefile-tweaks@4.09 static-libgcc@4.11)

# Proposed back-ports to maintenance branches and opam-repository:
# - Compatibility with binutils 2.36+ on mingw-w64 x64 (#10351; 4.12.1, 4.13.0)
#   **Critical**: fix in 4.12.1 is too high risk to back-port, this alters the
#                 linker flags instead. mingw-w64 x64 is unusable without this
BRANCHES+=(fix-binutils-2.36@4.11)
# - Compatibility with mingw-w64 headers 8.0.0 (#10062; 4.12.0)
#   **Critical**: both mingw-w64 ports require this tweak for the headers to
#                 behave correctly if user-code loads <stdio.h> (or other
#                 headers pulling in mingw.h) before <caml/config.h>
BRANCHES+=(fix-mingw-lld@4.11)
# - Fix parallel generation of header programs (#2267 + #8626; 4.09.0)
#   Prerequisite for faster-flexdll on 4.08 (and also fixes Cygwin compilation
#   on 4.08)
BRANCHES+=(merge-headers@4.08)
# - FlexDLL bootstrapping overhaul (#10135; 4.13.0)
#   Vastly improves the build performance and reliability on Windows. Simplifies
#   the packaging for ocaml-base-compiler.
BRANCHES+=(faster-flexdll-4.12@4.12 faster-flexdll-4.11@4.11@fixup faster-flexdll-4.08@4.08@fixup)
# - Add --disable-stdlib-manpages to configure (#8835 and #9335; 4.11.0)
#   --disable-stdlib-manpages was added in 4.10.0 but broken by the time of
#   release. The build is very time-consuming, especially on Windows, so this is
#   recommended to allow the Windows configuration to use it
BRANCHES+=(fix-stdlib-manpages-4.09@4.09 fix-stdlib-manpages@4.10)
# - Add --disable-ocamltest to configure (#9250; 4.11.0)
#   ocamltest is never installed, but the build uses time and resources. Propose
#   back-porting this to save time on older compiler builds.
BRANCHES+=(disable-ocamltest@4.10)

# These all simplify the testing infrastructure, but aren't required:
# - Add --enable-warn-error (from #9625; 4.12.0)
# - Fix warn-error issues with win32graph (ocaml/graphics#28)
# - Allow make's default target to build the compiler (from #8951; 4.10.0)
# - Revert the Wdeclaration-after-statement dev-error (from #1176; 4.11.0 - back-ports part of #11051; 5.0.0)
# - Don't define _INTEGRAL_MAX_BITS in Windows stat implementation (#9686; 4.12.0)
BRANCHES+=(win32-safe-string@4.08 _integral_max_bits@4.11 declaration-after-statement@4.14 warn-error@4.11 make-default-target@4.09)

# This slightly simplifies the patch rebasing infrastructure, as it stops
# configure from being completely rejected
# - Ensure that configure can be patched (#9847; 4.12.0)
BRANCHES+=(no-configure@4.11)

# Back-ports
# NB These back-ports have been selected to ease the back-porting of the main
# PRs. Some of the back-ports will want tweaking after the PRs are finalised.
# For example, back-porting #1941 and #8992 makes the -set-global-string portion
# of enable-relative rebase more easily, but the better back-port would be to
# add the argument using the pre-4.10 mechanisms.
# - Original long shebang "fix" (#8622; 4.10.0)
# - Hardening of -use-runtime for spaces and symbols (#11112; 5.0.0)
# - Expose Config.ext_exe (from #9652; 4.12.0)
# - Caml_inline macro (from #1176; 4.11.0)
# - _T / T macro (#2075; 4.09.0)
# - ocamlrun -config (#9284; 4.13.0)
# - Eliminate tools/ocamlmklibconfig.ml (#10204; 4.13.0)
# - Add HAS_REALPATH to s.h (from #10047; 4.13.0)
# - Add runtime/build_config.h (from #10451; 4.13.0)
# - Simplification of ocamlcp/ocamloptp processing (#1941; 4.09.0)
# - Share argument implementations (from #8992; 4.10.0)
BRANCHES+=(ext_exe@4.11 shebang@4.09 c89_headers@4.10 rename_T_macro@4.08 use-runtime-evil@4.14 use-runtime-evil-fixup@fixup ocamlrun-config@4.12 ocamlmklibconfig-cleanup@4.12 unix-realpath@4.12 build_config@4.12 build_config-4.11@fixup ocamlc-dedup3@4.08 shared_args-4.09@4.09 shared_args-4.08@4.08)

# Branches
#  - misc-win-fixes
#  - windows-ln
#  - one-camlheader
#  - target-bindir
#  - ld.conf-CRLF
#  - ld.conf-search
#  - ld.conf-relative
#  - compiled-primitives
#  - enable-relative
BRANCHES+=(misc-win-fixes windows-ln one-camlheader target-bindir unified-target-bindir@fixup ld.conf-CRLF ld.conf-search ld.conf-relative unified-ld.conf-relative@4.14 compiled-primitives enable-relative unified-enable-relative@fixup unified-enable-relative-4.x@fixup unified-enable-relative-4.11@fixup cmmgen-4.09@fixup~1 cmmgen-4.08@fixup~1)

TARGETS=(5.0.0-alpha1 4.14.0 4.13.1 4.12.1 4.11.2 4.10.2 4.09.1 4.08.1)

# Check the branches all exist and collect the commits to stack
for branch in "${BRANCHES[@]}"; do
  branch="${branch%%@*}"
  if ! git rev-parse --verify $branch &> /dev/null; then
    if ! git rev-parse --verify origin/$branch &> /dev/null; then
      echo "Both $branch and origin/$branch do not exist!" >&2
      exit 1
    else
      git branch --track $branch origin/$branch
    fi
  fi
done

fault=0
for root in "${TARGETS[@]}"; do
  if ! git rev-parse --verify $root &> /dev/null; then
    echo "Target $root not found" >&2
    fault=1
  fi
done
if ((fault)); then
  exit 1
fi

COMMITS=()
WORKING=()
if [[ ! -e $state_file ]]; then
  if [[ -n "$(git status --porcelain)" ]]; then
    echo 'The working tree is not clean' >&2
    exit 1
  fi

  git clean -dfX &> /dev/null

  # Calculate the menu. First, determine the initial commit list from the
  # branches.
  for entry in "${BRANCHES[@]}"; do
    upstream="${entry#*@}"
    if [[ $upstream = $entry ]]; then
      upstream='trunk'
    fi
    branch="${entry%%@*}"
    if [[ $upstream =~ ^fixup(~[0-9])?$ ]]; then
      count="${upstream#fixup~}"
      if [[ $count = $upstream ]]; then
        count=0
      fi
      commit="$(git log --format=%h -n 1 "$branch")"
      COMMITS+=("adjust $count $entry $commit")
    elif [[ $upstream =~ @fixup$ ]]; then
      upstream="${upstream%@fixup}"
      cmd="$branch"
      count=-1
      while read -r commit; do
        cmd="$cmd $commit"
        ((count++))
      done < <(git log upstream/$upstream..$branch --format="%h" --reverse)
      COMMITS+=("adjust $count $cmd")
    else
      while read -r entry; do
        commit="${entry%% *}"
        if [[ ${entry#* } = 'Bootstrap' ]]; then
          # XXX COMBAK Must check that the commit only changes boot/ocamlc and/or boot/ocamllex
          COMMITS+=("bootstrap $commit")
        else
          COMMITS+=("pick $commit")
        fi
      done < <(git log upstream/$upstream..$branch --format="%h %s" --reverse)
    fi
  done

  # Now generate commands for each target branch
  for root in "${TARGETS[@]}"; do
    COMMANDS+=("branch $root")
  done
else
  if [[ -n "$(git ls-files --exclude-standard --others)" ]]; then
    echo 'Untracked files in the working directory' >&2
    exit 1
  elif [[ -n "$(git diff --stat)" ]]; then
    echo 'Unstaged changes in the working directory' >&2
    exit 1
  fi

  # Load the stack state
  phase=0
  while read -r line; do
    case ${line%% *} in
      pick|bootstrap|fixup|adjust)
        if ((phase)); then
          WORKING+=("$line")
        else
          COMMITS+=("$line")
        fi;;
      commit)
        COMMANDS+=("$line")
        phase=1;;
      branch)
        COMMANDS+=("$line");;
      target)
        target="${line#* }";;
      *)
        echo "Unrecognised command: $line" >&2
        phase=2;;
    esac
  done < <(cat "$state_file")
  if [[ $phase -gt 1 ]]; then
    exit 1
  fi
  rm "$state_file"
fi

function abort
{
  echo "Branch: $branch for $target"
  echo "  $action"
  for commit in "${COMMITS[@]}"; do
    echo "$commit"
  done > "$state_file"
  echo "target $target" >> "$state_file"
  echo "commit $instr" >> "$state_file"
  aborting=1
}

function merge-base
{
  local base="$(git merge-base "$1" "$2")"
  # There's an error in the branching history for 4.13, possibly caused by PRs
  # merged shortly after it was branched. The effect is that there are two
  # "last commit before branching 4.13" commits in the history which causes the
  # common parent dd7927 to be selected. We manually amend this to 4.13's
  # merge-base.
  if [[ $base = 'dd7927e156b7cb2f9cb73d2d54a15a9c81921392' ]]; then
    base='621753f3eec9de91495a25723de00cef33a9e35a'
  fi
  echo "$base"
}

# Return status 0 only if the commit specified by $1 is based on a branch which
# is newer than the commit specified by $2 (i.e. cherry-picking $1 onto $2 would
# be a back-port, not a revert)
function is-backport
{
  commit="$1"
  target="$2"
  # The multicore merge history (from #10831) causes issues for `git merge-base`
  # $pre_10831 is the last commit on trunk before #10831 was merged. If that
  # commit is _not_ an ancestor of $target, then we use that instead of the tip
  # of trunk to work out the merge-base, as this avoids the complicated rebase
  # and merge history in #10831.
  pre_10831='263a2a429c'
  if git merge-base --is-ancestor $pre_10831 "$target"; then
    trunk='upstream/trunk'
  else
    trunk=$pre_10831
  fi
  target_sha="$(git rev-list -n 1 "$target")"
  target_mergebase="$(merge-base "$target" $trunk)"
  mergebase="$(merge-base "$commit" "$target")"
  if [[ $mergebase = $target_sha ]]; then
    # Commit is based on target!
    return
  elif [[ $mergebase = $target_mergebase ]]; then
    # The common point between $commit and $target is $target's merge-base with
    # trunk. That means $commit is newer, as otherwise the common point would
    # be the merge-base of $commit and trunk.
    return
  fi

  # This isn't a back-port
  return 1
}

function rebase
{
  while [[ ${#WORKING[@]} -gt 0 ]]; do
    instr="${WORKING[0]}"
    WORKING=("${WORKING[@]:1}")
    sha="${instr#* }"
    verb="${instr%% *}"
    case $verb in
      adjust)
        # INSTR[0] = adjust; INSTR[1] = count; INSTR[2] = description; INSTR[@]:3 = commits
        INSTR=($instr)
        if ! is-backport "${INSTR[3]}" "$target"; then
          COMMITS+=("$instr")
          echo "Skipping ${INSTR[2]} as it's older than $target"
        else
          if [[ ${INSTR[1]} -eq 0 ]]; then
            POPPED=()
          else
            POPPED=("${COMMITS[@]: -${INSTR[1]}}")
            COMMITS=("${COMMITS[@]:0:$((${#COMMITS[@]} - ${INSTR[1]}))}")
            git reset --hard HEAD~${INSTR[1]} &> /dev/null
          fi
          INSTR=("${INSTR[@]:3}")
          ADDITIONS=()
          while [[ ${#INSTR[@]} -gt 0 ]]; do
            sha="${INSTR[0]}"
            INSTR=("${INSTR[@]:1}")
            ADDITIONS+=("fixup $sha")
            if [[ ${#POPPED[@]} -gt 0 ]]; then
              ADDITIONS+=("${POPPED[0]}")
              POPPED=("${POPPED[@]:1}")
            fi
          done
          WORKING=("${ADDITIONS[@]}" "${POPPED[@]}" "${WORKING[@]}")
        fi;;
      pick|fixup)
        if ! is-backport "$sha" "$target"; then
          COMMITS+=("$instr")
          echo "Skipping $sha as it's older than $target ($(git log -n 1 --format=%s $sha))"
          if [[ $verb = 'fixup' ]]; then
            echo "Should not be seeing a skipped commit for fixup?" >&2
            exit 1
          fi
        else
          if [[ $verb = 'fixup' ]]; then
            echo "fixup $sha on $target ($(git log -n 1 --format=%s $sha))"
            msg="$(git rev-parse --short HEAD)"
            amend='--amend'
            next=''
          else
            echo "cherry-pick $sha to $target ($(git log -n 1 --format=%s $sha))"
            msg="$sha"
            amend=''
            next='pick $head'
          fi
          git cherry-pick --no-commit "$sha" >& /dev/null
          git reset -- Changes &> /dev/null
          git checkout -- Changes &> /dev/null
          if reconfigure; then
            TO_DELETE=()
            while read -r status; do
              case ${status:0:2} in
                DU)
                  git reset -- "${status:3}" &> /dev/null
                  TO_DELETE+=("${status:3}");;
                UU)
                  if ! grep -q '^<<<<<' "${status:3}" ; then
                    git add -- "${status:3}"
                  else
                    git reset -- "${status:3}" &>/dev/null
                  fi;;
              esac
            done < <(git status --porcelain)

            if [[ -n $(git diff --stat) ]]; then
              abort
              git status
              echo
              echo "Please resolve changes, add to the index and re-run $0"
            else
              for file in "${TO_DELETE[@]}"; do
                rm -f "$file"
              done
              commit "$msg" "$next" "$instr" "$amend"
            fi
          fi
        fi;;
      bootstrap)
        echo "Bootstrap $target ($sha)"
        cached="$(git reflog --format='%h %p' | grep " $(git rev-parse --short HEAD)$" | head -n 1 | cut -f1 -d' ')"
        if [[ -n $cached ]] && git diff-tree --no-commit-id --name-only -r "$cached" | grep -Fq 'boot/ocaml'; then
          echo "Re-using previous bootstrap computation from $cached"
          git merge --ff-only $cached &> /dev/null
          COMMITS+=("$instr")
        else
          echo "Bootstrapping..."
          if ! ./configure --disable-native-compiler --disable-ocamldoc --disable-ocamltest --disable-debugger > _log 2>&1; then
            cat _log
            rm _log
            abort
            echo "configure failed: either fix or erase $state_file"
          elif ! make -j world > _log 2>&1; then
            cat _log
            rm _log
            abort
            echo "make world failed: either fix or erase $state_file"
          elif ! make -j bootstrap > _log 2>&1; then
            cat _log
            rm _log
            abort
            echo "make bootstrap failed: either fix or erase $state_file"
          else
            rm _log
            git clean -dfX &> /dev/null
            # OCaml 4.06 and earlier
            if [[ -e boot/ocamldep ]]; then
              git add -- boot/ocamldep
            fi
            git add -- boot/ocamlc boot/ocamllex
            commit "$sha" "$instr" "$instr"
          fi
        fi;;
      *)
        echo "Internal error: unrecognised command $instr" >&2
        exit 1;;
    esac
    if ((aborting)); then
      for instr in "${WORKING[@]}"; do
        echo "$instr" >> "$state_file"
      done
      WORKING=()
    fi
  done
}

function reconfigure
{
  reconfigure=0
  while read -r item; do
    case $item in
      configure|configure.ac|aclocal.m4|build-aux/*)
        reconfigure=1;;
    esac
  done < <(git diff --name-only --cached)
  if ((reconfigure)); then
    echo "configure.ac has been changed - regenerating configure"
    if [[ -e tools/autogen ]]; then
      autogen=tools/autogen
    else
      autogen=./autogen
    fi
    if docker run --rm -it -v $PWD:/home/opam/ocaml -w /home/opam/ocaml autogen $autogen; then
      git add -- configure
    else
      abort
      echo "Regenerating configure failed - please fix and re-run $0"
      return 1
    fi
  fi
}

function commit
{
  if reconfigure; then
    if [[ -z "$(git status --porcelain)" ]]; then
      echo "Commit $1 skipped for $target (empty)"
      # Don't put an empty fixup back onto the list
      if [[ -n $2 ]]; then
        COMMITS+=("$3")
      fi
    else
      if ! git commit --reuse-message="$1" $4 &> _log; then
        cat _log
        rm _log
        abort
        echo "Commit failed - please fix and re-run $0"
        return
      fi
      rm -f _log
      git rebase --committer-date-is-author-date HEAD~1 &> /dev/null
      head="$(git rev-parse --short HEAD)"
      if [[ -n $2 ]]; then
        eval "com=\"$2\""
        COMMITS+=("$com")
      else
        previous="${COMMITS[-1]}"
        previous="${previous% *}"
        COMMITS[-1]="$previous $head"
      fi
    fi
  fi
}

aborting=0
while [[ ${#COMMANDS[@]} -gt 0 ]]; do
  instr="${COMMANDS[0]}"
  COMMANDS=("${COMMANDS[@]:1}")
  arg="${instr#* }"
  case ${instr%% *} in
    commit)
      git clean -dfX &> /dev/null
      verb="${arg% *}"
      if [[ $verb = 'fixup' ]]; then
        msg="$(git rev-parse --short HEAD)"
        next=''
        amend='--amend'
      else
        msg="${arg#* }"
        next="$verb \$head"
        amend=''
      fi
      instr="$arg"
      commit "$msg" "$next" "$arg" "$amend"
      rebase;;
    branch)
      target_branch="backport-${arg%.*}"
      echo "Creating branch $target_branch"
      target="$arg"
      git checkout -B "$target_branch" "$arg" &> /dev/null
      WORKING=("${COMMITS[@]}")
      COMMITS=()
      rebase;;
    *)
      echo "Internal error: unrecognised command $instr" >&2
      exit 1;;
  esac
  if ((aborting)); then
    for instr in "${COMMANDS[@]}"; do
      echo "$instr" >> "$state_file"
    done
    COMMANDS=()
  fi
done

cd ..
if ((!aborting)); then
  git submodule update
fi
